//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator. DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package openai

import (
	"context"
	"errors"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// APIClient contains the methods for the OpenAIAPI group.
// Don't use this type directly, use a constructor function instead.
type APIClient struct {
	internal *azcore.Client
}

// CancelFineTune - Immediately cancel a fine-tune job.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - fineTuneID - The ID of the fine-tune job to cancel
//   - options - APIClientCancelFineTuneOptions contains the optional parameters for the APIClient.CancelFineTune method.
func (client *APIClient) CancelFineTune(ctx context.Context, fineTuneID string, options *APIClientCancelFineTuneOptions) (APIClientCancelFineTuneResponse, error) {
	var err error
	req, err := client.cancelFineTuneCreateRequest(ctx, fineTuneID, options)
	if err != nil {
		return APIClientCancelFineTuneResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCancelFineTuneResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCancelFineTuneResponse{}, err
	}
	resp, err := client.cancelFineTuneHandleResponse(httpResp)
	return resp, err
}

// cancelFineTuneCreateRequest creates the CancelFineTune request.
func (client *APIClient) cancelFineTuneCreateRequest(ctx context.Context, fineTuneID string, options *APIClientCancelFineTuneOptions) (*policy.Request, error) {
	urlPath := "/fine-tunes/{fine_tune_id}/cancel"
	if fineTuneID == "" {
		return nil, errors.New("parameter fineTuneID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fine_tune_id}", url.PathEscape(fineTuneID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// cancelFineTuneHandleResponse handles the CancelFineTune response.
func (client *APIClient) cancelFineTuneHandleResponse(resp *http.Response) (APIClientCancelFineTuneResponse, error) {
	result := APIClientCancelFineTuneResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FineTune); err != nil {
		return APIClientCancelFineTuneResponse{}, err
	}
	return result, nil
}

// CreateChatCompletion - Creates a model response for the given chat conversation.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientCreateChatCompletionOptions contains the optional parameters for the APIClient.CreateChatCompletion
//     method.
func (client *APIClient) CreateChatCompletion(ctx context.Context, body CreateChatCompletionRequest, options *APIClientCreateChatCompletionOptions) (APIClientCreateChatCompletionResponse, error) {
	var err error
	req, err := client.createChatCompletionCreateRequest(ctx, body, options)
	if err != nil {
		return APIClientCreateChatCompletionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateChatCompletionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateChatCompletionResponse{}, err
	}
	resp, err := client.createChatCompletionHandleResponse(httpResp)
	return resp, err
}

// createChatCompletionCreateRequest creates the CreateChatCompletion request.
func (client *APIClient) createChatCompletionCreateRequest(ctx context.Context, body CreateChatCompletionRequest, options *APIClientCreateChatCompletionOptions) (*policy.Request, error) {
	urlPath := "/chat/completions"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createChatCompletionHandleResponse handles the CreateChatCompletion response.
func (client *APIClient) createChatCompletionHandleResponse(resp *http.Response) (APIClientCreateChatCompletionResponse, error) {
	result := APIClientCreateChatCompletionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateChatCompletionResponse); err != nil {
		return APIClientCreateChatCompletionResponse{}, err
	}
	return result, nil
}

// CreateCompletion - Creates a completion for the provided prompt and parameters.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientCreateCompletionOptions contains the optional parameters for the APIClient.CreateCompletion method.
func (client *APIClient) CreateCompletion(ctx context.Context, body CreateCompletionRequest, options *APIClientCreateCompletionOptions) (APIClientCreateCompletionResponse, error) {
	var err error
	req, err := client.createCompletionCreateRequest(ctx, body, options)
	if err != nil {
		return APIClientCreateCompletionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateCompletionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateCompletionResponse{}, err
	}
	resp, err := client.createCompletionHandleResponse(httpResp)
	return resp, err
}

// createCompletionCreateRequest creates the CreateCompletion request.
func (client *APIClient) createCompletionCreateRequest(ctx context.Context, body CreateCompletionRequest, options *APIClientCreateCompletionOptions) (*policy.Request, error) {
	urlPath := "/completions"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createCompletionHandleResponse handles the CreateCompletion response.
func (client *APIClient) createCompletionHandleResponse(resp *http.Response) (APIClientCreateCompletionResponse, error) {
	result := APIClientCreateCompletionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateCompletionResponse); err != nil {
		return APIClientCreateCompletionResponse{}, err
	}
	return result, nil
}

// CreateEdit - Creates a new edit for the provided input, instruction, and parameters.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientCreateEditOptions contains the optional parameters for the APIClient.CreateEdit method.
func (client *APIClient) CreateEdit(ctx context.Context, body CreateEditRequest, options *APIClientCreateEditOptions) (APIClientCreateEditResponse, error) {
	var err error
	req, err := client.createEditCreateRequest(ctx, body, options)
	if err != nil {
		return APIClientCreateEditResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateEditResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateEditResponse{}, err
	}
	resp, err := client.createEditHandleResponse(httpResp)
	return resp, err
}

// createEditCreateRequest creates the CreateEdit request.
func (client *APIClient) createEditCreateRequest(ctx context.Context, body CreateEditRequest, options *APIClientCreateEditOptions) (*policy.Request, error) {
	urlPath := "/edits"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createEditHandleResponse handles the CreateEdit response.
func (client *APIClient) createEditHandleResponse(resp *http.Response) (APIClientCreateEditResponse, error) {
	result := APIClientCreateEditResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateEditResponse); err != nil {
		return APIClientCreateEditResponse{}, err
	}
	return result, nil
}

// CreateEmbedding - Creates an embedding vector representing the input text.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientCreateEmbeddingOptions contains the optional parameters for the APIClient.CreateEmbedding method.
func (client *APIClient) CreateEmbedding(ctx context.Context, body CreateEmbeddingRequest, options *APIClientCreateEmbeddingOptions) (APIClientCreateEmbeddingResponse, error) {
	var err error
	req, err := client.createEmbeddingCreateRequest(ctx, body, options)
	if err != nil {
		return APIClientCreateEmbeddingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateEmbeddingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateEmbeddingResponse{}, err
	}
	resp, err := client.createEmbeddingHandleResponse(httpResp)
	return resp, err
}

// createEmbeddingCreateRequest creates the CreateEmbedding request.
func (client *APIClient) createEmbeddingCreateRequest(ctx context.Context, body CreateEmbeddingRequest, options *APIClientCreateEmbeddingOptions) (*policy.Request, error) {
	urlPath := "/embeddings"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createEmbeddingHandleResponse handles the CreateEmbedding response.
func (client *APIClient) createEmbeddingHandleResponse(resp *http.Response) (APIClientCreateEmbeddingResponse, error) {
	result := APIClientCreateEmbeddingResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateEmbeddingResponse); err != nil {
		return APIClientCreateEmbeddingResponse{}, err
	}
	return result, nil
}

// CreateFile - Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size
// of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need
// to increase the storage limit.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - file - Name of the JSON Lines [https://jsonlines.readthedocs.io/en/latest/] file to be uploaded.
//     If the purpose is set to "fine-tune", each line is a JSON record with "prompt" and "completion" fields representing your
//     training examples [/docs/guides/fine-tuning/prepare-training-data].
//   - purpose - The intended purpose of the uploaded documents.
//     Use "fine-tune" for Fine-tuning [/docs/api-reference/fine-tunes]. This allows us to validate the format of the uploaded
//     file.
//   - options - APIClientCreateFileOptions contains the optional parameters for the APIClient.CreateFile method.
func (client *APIClient) CreateFile(ctx context.Context, file io.ReadSeekCloser, purpose string, options *APIClientCreateFileOptions) (APIClientCreateFileResponse, error) {
	var err error
	req, err := client.createFileCreateRequest(ctx, file, purpose, options)
	if err != nil {
		return APIClientCreateFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateFileResponse{}, err
	}
	resp, err := client.createFileHandleResponse(httpResp)
	return resp, err
}

// createFileCreateRequest creates the CreateFile request.
func (client *APIClient) createFileCreateRequest(ctx context.Context, file io.ReadSeekCloser, purpose string, options *APIClientCreateFileOptions) (*policy.Request, error) {
	urlPath := "/files"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.SetMultipartFormData(req, map[string]any{
		"file":    file,
		"purpose": purpose,
	}); err != nil {
		return nil, err
	}
	return req, nil
}

// createFileHandleResponse handles the CreateFile response.
func (client *APIClient) createFileHandleResponse(resp *http.Response) (APIClientCreateFileResponse, error) {
	result := APIClientCreateFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.File); err != nil {
		return APIClientCreateFileResponse{}, err
	}
	return result, nil
}

// CreateFineTune - Creates a job that fine-tunes a specified model from a given dataset.
// Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
// Learn more about Fine-tuning [/docs/guides/fine-tuning]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientCreateFineTuneOptions contains the optional parameters for the APIClient.CreateFineTune method.
func (client *APIClient) CreateFineTune(ctx context.Context, body CreateFineTuneRequest, options *APIClientCreateFineTuneOptions) (APIClientCreateFineTuneResponse, error) {
	var err error
	req, err := client.createFineTuneCreateRequest(ctx, body, options)
	if err != nil {
		return APIClientCreateFineTuneResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateFineTuneResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateFineTuneResponse{}, err
	}
	resp, err := client.createFineTuneHandleResponse(httpResp)
	return resp, err
}

// createFineTuneCreateRequest creates the CreateFineTune request.
func (client *APIClient) createFineTuneCreateRequest(ctx context.Context, body CreateFineTuneRequest, options *APIClientCreateFineTuneOptions) (*policy.Request, error) {
	urlPath := "/fine-tunes"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createFineTuneHandleResponse handles the CreateFineTune response.
func (client *APIClient) createFineTuneHandleResponse(resp *http.Response) (APIClientCreateFineTuneResponse, error) {
	result := APIClientCreateFineTuneResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FineTune); err != nil {
		return APIClientCreateFineTuneResponse{}, err
	}
	return result, nil
}

// CreateImage - Creates an image given a prompt.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientCreateImageOptions contains the optional parameters for the APIClient.CreateImage method.
func (client *APIClient) CreateImage(ctx context.Context, body CreateImageRequest, options *APIClientCreateImageOptions) (APIClientCreateImageResponse, error) {
	var err error
	req, err := client.createImageCreateRequest(ctx, body, options)
	if err != nil {
		return APIClientCreateImageResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateImageResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateImageResponse{}, err
	}
	resp, err := client.createImageHandleResponse(httpResp)
	return resp, err
}

// createImageCreateRequest creates the CreateImage request.
func (client *APIClient) createImageCreateRequest(ctx context.Context, body CreateImageRequest, options *APIClientCreateImageOptions) (*policy.Request, error) {
	urlPath := "/images/generations"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createImageHandleResponse handles the CreateImage response.
func (client *APIClient) createImageHandleResponse(resp *http.Response) (APIClientCreateImageResponse, error) {
	result := APIClientCreateImageResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ImagesResponse); err != nil {
		return APIClientCreateImageResponse{}, err
	}
	return result, nil
}

// CreateImageEdit - Creates an edited or extended image given an original image and a prompt.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - imageParam - The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must
//     have transparency, which will be used as the mask.
//   - prompt - A text description of the desired image(s). The maximum length is 1000 characters.
//   - options - APIClientCreateImageEditOptions contains the optional parameters for the APIClient.CreateImageEdit method.
func (client *APIClient) CreateImageEdit(ctx context.Context, imageParam io.ReadSeekCloser, prompt string, options *APIClientCreateImageEditOptions) (APIClientCreateImageEditResponse, error) {
	var err error
	req, err := client.createImageEditCreateRequest(ctx, imageParam, prompt, options)
	if err != nil {
		return APIClientCreateImageEditResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateImageEditResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateImageEditResponse{}, err
	}
	resp, err := client.createImageEditHandleResponse(httpResp)
	return resp, err
}

// createImageEditCreateRequest creates the CreateImageEdit request.
func (client *APIClient) createImageEditCreateRequest(ctx context.Context, imageParam io.ReadSeekCloser, prompt string, options *APIClientCreateImageEditOptions) (*policy.Request, error) {
	urlPath := "/images/edits"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.SetMultipartFormData(req, map[string]any{
		"imageParam":     imageParam,
		"Mask":           options.Mask,
		"prompt":         prompt,
		"N":              options.N,
		"Size":           options.Size,
		"ResponseFormat": options.ResponseFormat,
		"User":           options.User,
	}); err != nil {
		return nil, err
	}
	return req, nil
}

// createImageEditHandleResponse handles the CreateImageEdit response.
func (client *APIClient) createImageEditHandleResponse(resp *http.Response) (APIClientCreateImageEditResponse, error) {
	result := APIClientCreateImageEditResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ImagesResponse); err != nil {
		return APIClientCreateImageEditResponse{}, err
	}
	return result, nil
}

// CreateImageVariation - Creates a variation of a given image.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - imageParam - The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
//   - options - APIClientCreateImageVariationOptions contains the optional parameters for the APIClient.CreateImageVariation
//     method.
func (client *APIClient) CreateImageVariation(ctx context.Context, imageParam io.ReadSeekCloser, options *APIClientCreateImageVariationOptions) (APIClientCreateImageVariationResponse, error) {
	var err error
	req, err := client.createImageVariationCreateRequest(ctx, imageParam, options)
	if err != nil {
		return APIClientCreateImageVariationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateImageVariationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateImageVariationResponse{}, err
	}
	resp, err := client.createImageVariationHandleResponse(httpResp)
	return resp, err
}

// createImageVariationCreateRequest creates the CreateImageVariation request.
func (client *APIClient) createImageVariationCreateRequest(ctx context.Context, imageParam io.ReadSeekCloser, options *APIClientCreateImageVariationOptions) (*policy.Request, error) {
	urlPath := "/images/variations"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.SetMultipartFormData(req, map[string]any{
		"imageParam":     imageParam,
		"N":              options.N,
		"Size":           options.Size,
		"ResponseFormat": options.ResponseFormat,
		"User":           options.User,
	}); err != nil {
		return nil, err
	}
	return req, nil
}

// createImageVariationHandleResponse handles the CreateImageVariation response.
func (client *APIClient) createImageVariationHandleResponse(resp *http.Response) (APIClientCreateImageVariationResponse, error) {
	result := APIClientCreateImageVariationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ImagesResponse); err != nil {
		return APIClientCreateImageVariationResponse{}, err
	}
	return result, nil
}

// CreateModeration - Classifies if text violates OpenAI's Content Policy
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientCreateModerationOptions contains the optional parameters for the APIClient.CreateModeration method.
func (client *APIClient) CreateModeration(ctx context.Context, body CreateModerationRequest, options *APIClientCreateModerationOptions) (APIClientCreateModerationResponse, error) {
	var err error
	req, err := client.createModerationCreateRequest(ctx, body, options)
	if err != nil {
		return APIClientCreateModerationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateModerationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateModerationResponse{}, err
	}
	resp, err := client.createModerationHandleResponse(httpResp)
	return resp, err
}

// createModerationCreateRequest creates the CreateModeration request.
func (client *APIClient) createModerationCreateRequest(ctx context.Context, body CreateModerationRequest, options *APIClientCreateModerationOptions) (*policy.Request, error) {
	urlPath := "/moderations"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
		return nil, err
	}
	return req, nil
}

// createModerationHandleResponse handles the CreateModeration response.
func (client *APIClient) createModerationHandleResponse(resp *http.Response) (APIClientCreateModerationResponse, error) {
	result := APIClientCreateModerationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateModerationResponse); err != nil {
		return APIClientCreateModerationResponse{}, err
	}
	return result, nil
}

// CreateTranscription - Transcribes audio into the input language.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - file - The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or
//     webm.
//   - model - ID of the model to use. Only whisper-1 is currently available.
//   - options - APIClientCreateTranscriptionOptions contains the optional parameters for the APIClient.CreateTranscription method.
func (client *APIClient) CreateTranscription(ctx context.Context, file io.ReadSeekCloser, model CreateTranscriptionRequestModel, options *APIClientCreateTranscriptionOptions) (APIClientCreateTranscriptionResponse, error) {
	var err error
	req, err := client.createTranscriptionCreateRequest(ctx, file, model, options)
	if err != nil {
		return APIClientCreateTranscriptionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateTranscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateTranscriptionResponse{}, err
	}
	resp, err := client.createTranscriptionHandleResponse(httpResp)
	return resp, err
}

// createTranscriptionCreateRequest creates the CreateTranscription request.
func (client *APIClient) createTranscriptionCreateRequest(ctx context.Context, file io.ReadSeekCloser, model CreateTranscriptionRequestModel, options *APIClientCreateTranscriptionOptions) (*policy.Request, error) {
	urlPath := "/audio/transcriptions"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.SetMultipartFormData(req, map[string]any{
		"file":           file,
		"model":          model,
		"Prompt":         options.Prompt,
		"ResponseFormat": options.ResponseFormat,
		"Temperature":    options.Temperature,
		"Language":       options.Language,
	}); err != nil {
		return nil, err
	}
	return req, nil
}

// createTranscriptionHandleResponse handles the CreateTranscription response.
func (client *APIClient) createTranscriptionHandleResponse(resp *http.Response) (APIClientCreateTranscriptionResponse, error) {
	result := APIClientCreateTranscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateTranscriptionResponse); err != nil {
		return APIClientCreateTranscriptionResponse{}, err
	}
	return result, nil
}

// CreateTranslation - Translates audio into English.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - file - The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
//   - model - ID of the model to use. Only whisper-1 is currently available.
//   - options - APIClientCreateTranslationOptions contains the optional parameters for the APIClient.CreateTranslation method.
func (client *APIClient) CreateTranslation(ctx context.Context, file io.ReadSeekCloser, model CreateTranslationRequestModel, options *APIClientCreateTranslationOptions) (APIClientCreateTranslationResponse, error) {
	var err error
	req, err := client.createTranslationCreateRequest(ctx, file, model, options)
	if err != nil {
		return APIClientCreateTranslationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientCreateTranslationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientCreateTranslationResponse{}, err
	}
	resp, err := client.createTranslationHandleResponse(httpResp)
	return resp, err
}

// createTranslationCreateRequest creates the CreateTranslation request.
func (client *APIClient) createTranslationCreateRequest(ctx context.Context, file io.ReadSeekCloser, model CreateTranslationRequestModel, options *APIClientCreateTranslationOptions) (*policy.Request, error) {
	urlPath := "/audio/translations"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	if err := runtime.SetMultipartFormData(req, map[string]any{
		"file":           file,
		"model":          model,
		"Prompt":         options.Prompt,
		"ResponseFormat": options.ResponseFormat,
		"Temperature":    options.Temperature,
	}); err != nil {
		return nil, err
	}
	return req, nil
}

// createTranslationHandleResponse handles the CreateTranslation response.
func (client *APIClient) createTranslationHandleResponse(resp *http.Response) (APIClientCreateTranslationResponse, error) {
	result := APIClientCreateTranslationResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.CreateTranslationResponse); err != nil {
		return APIClientCreateTranslationResponse{}, err
	}
	return result, nil
}

// DeleteFile - Delete a file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - fileID - The ID of the file to use for this request
//   - options - APIClientDeleteFileOptions contains the optional parameters for the APIClient.DeleteFile method.
func (client *APIClient) DeleteFile(ctx context.Context, fileID string, options *APIClientDeleteFileOptions) (APIClientDeleteFileResponse, error) {
	var err error
	req, err := client.deleteFileCreateRequest(ctx, fileID, options)
	if err != nil {
		return APIClientDeleteFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientDeleteFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientDeleteFileResponse{}, err
	}
	resp, err := client.deleteFileHandleResponse(httpResp)
	return resp, err
}

// deleteFileCreateRequest creates the DeleteFile request.
func (client *APIClient) deleteFileCreateRequest(ctx context.Context, fileID string, options *APIClientDeleteFileOptions) (*policy.Request, error) {
	urlPath := "/files/{file_id}"
	if fileID == "" {
		return nil, errors.New("parameter fileID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{file_id}", url.PathEscape(fileID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteFileHandleResponse handles the DeleteFile response.
func (client *APIClient) deleteFileHandleResponse(resp *http.Response) (APIClientDeleteFileResponse, error) {
	result := APIClientDeleteFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeleteFileResponse); err != nil {
		return APIClientDeleteFileResponse{}, err
	}
	return result, nil
}

// DeleteModel - Delete a fine-tuned model. You must have the Owner role in your organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - model - The model to delete
//   - options - APIClientDeleteModelOptions contains the optional parameters for the APIClient.DeleteModel method.
func (client *APIClient) DeleteModel(ctx context.Context, model string, options *APIClientDeleteModelOptions) (APIClientDeleteModelResponse, error) {
	var err error
	req, err := client.deleteModelCreateRequest(ctx, model, options)
	if err != nil {
		return APIClientDeleteModelResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientDeleteModelResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientDeleteModelResponse{}, err
	}
	resp, err := client.deleteModelHandleResponse(httpResp)
	return resp, err
}

// deleteModelCreateRequest creates the DeleteModel request.
func (client *APIClient) deleteModelCreateRequest(ctx context.Context, model string, options *APIClientDeleteModelOptions) (*policy.Request, error) {
	urlPath := "/models/{model}"
	if model == "" {
		return nil, errors.New("parameter model cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{model}", url.PathEscape(model))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// deleteModelHandleResponse handles the DeleteModel response.
func (client *APIClient) deleteModelHandleResponse(resp *http.Response) (APIClientDeleteModelResponse, error) {
	result := APIClientDeleteModelResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeleteModelResponse); err != nil {
		return APIClientDeleteModelResponse{}, err
	}
	return result, nil
}

// DownloadFile - Returns the contents of the specified file
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - fileID - The ID of the file to use for this request
//   - options - APIClientDownloadFileOptions contains the optional parameters for the APIClient.DownloadFile method.
func (client *APIClient) DownloadFile(ctx context.Context, fileID string, options *APIClientDownloadFileOptions) (APIClientDownloadFileResponse, error) {
	var err error
	req, err := client.downloadFileCreateRequest(ctx, fileID, options)
	if err != nil {
		return APIClientDownloadFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientDownloadFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientDownloadFileResponse{}, err
	}
	resp, err := client.downloadFileHandleResponse(httpResp)
	return resp, err
}

// downloadFileCreateRequest creates the DownloadFile request.
func (client *APIClient) downloadFileCreateRequest(ctx context.Context, fileID string, options *APIClientDownloadFileOptions) (*policy.Request, error) {
	urlPath := "/files/{file_id}/content"
	if fileID == "" {
		return nil, errors.New("parameter fileID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{file_id}", url.PathEscape(fileID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// downloadFileHandleResponse handles the DownloadFile response.
func (client *APIClient) downloadFileHandleResponse(resp *http.Response) (APIClientDownloadFileResponse, error) {
	result := APIClientDownloadFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Value); err != nil {
		return APIClientDownloadFileResponse{}, err
	}
	return result, nil
}

// ListFiles - Returns a list of files that belong to the user's organization.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientListFilesOptions contains the optional parameters for the APIClient.ListFiles method.
func (client *APIClient) ListFiles(ctx context.Context, options *APIClientListFilesOptions) (APIClientListFilesResponse, error) {
	var err error
	req, err := client.listFilesCreateRequest(ctx, options)
	if err != nil {
		return APIClientListFilesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientListFilesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientListFilesResponse{}, err
	}
	resp, err := client.listFilesHandleResponse(httpResp)
	return resp, err
}

// listFilesCreateRequest creates the ListFiles request.
func (client *APIClient) listFilesCreateRequest(ctx context.Context, options *APIClientListFilesOptions) (*policy.Request, error) {
	urlPath := "/files"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFilesHandleResponse handles the ListFiles response.
func (client *APIClient) listFilesHandleResponse(resp *http.Response) (APIClientListFilesResponse, error) {
	result := APIClientListFilesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListFilesResponse); err != nil {
		return APIClientListFilesResponse{}, err
	}
	return result, nil
}

// ListFineTuneEvents - Get fine-grained status updates for a fine-tune job.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - fineTuneID - The ID of the fine-tune job to get events for.
//   - options - APIClientListFineTuneEventsOptions contains the optional parameters for the APIClient.ListFineTuneEvents method.
func (client *APIClient) ListFineTuneEvents(ctx context.Context, fineTuneID string, options *APIClientListFineTuneEventsOptions) (APIClientListFineTuneEventsResponse, error) {
	var err error
	req, err := client.listFineTuneEventsCreateRequest(ctx, fineTuneID, options)
	if err != nil {
		return APIClientListFineTuneEventsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientListFineTuneEventsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientListFineTuneEventsResponse{}, err
	}
	resp, err := client.listFineTuneEventsHandleResponse(httpResp)
	return resp, err
}

// listFineTuneEventsCreateRequest creates the ListFineTuneEvents request.
func (client *APIClient) listFineTuneEventsCreateRequest(ctx context.Context, fineTuneID string, options *APIClientListFineTuneEventsOptions) (*policy.Request, error) {
	urlPath := "/fine-tunes/{fine_tune_id}/events"
	if fineTuneID == "" {
		return nil, errors.New("parameter fineTuneID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fine_tune_id}", url.PathEscape(fineTuneID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Stream != nil {
		reqQP.Set("stream", strconv.FormatBool(*options.Stream))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFineTuneEventsHandleResponse handles the ListFineTuneEvents response.
func (client *APIClient) listFineTuneEventsHandleResponse(resp *http.Response) (APIClientListFineTuneEventsResponse, error) {
	result := APIClientListFineTuneEventsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListFineTuneEventsResponse); err != nil {
		return APIClientListFineTuneEventsResponse{}, err
	}
	return result, nil
}

// ListFineTunes - List your organization's fine-tuning jobs
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientListFineTunesOptions contains the optional parameters for the APIClient.ListFineTunes method.
func (client *APIClient) ListFineTunes(ctx context.Context, options *APIClientListFineTunesOptions) (APIClientListFineTunesResponse, error) {
	var err error
	req, err := client.listFineTunesCreateRequest(ctx, options)
	if err != nil {
		return APIClientListFineTunesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientListFineTunesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientListFineTunesResponse{}, err
	}
	resp, err := client.listFineTunesHandleResponse(httpResp)
	return resp, err
}

// listFineTunesCreateRequest creates the ListFineTunes request.
func (client *APIClient) listFineTunesCreateRequest(ctx context.Context, options *APIClientListFineTunesOptions) (*policy.Request, error) {
	urlPath := "/fine-tunes"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listFineTunesHandleResponse handles the ListFineTunes response.
func (client *APIClient) listFineTunesHandleResponse(resp *http.Response) (APIClientListFineTunesResponse, error) {
	result := APIClientListFineTunesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListFineTunesResponse); err != nil {
		return APIClientListFineTunesResponse{}, err
	}
	return result, nil
}

// ListModels - Lists the currently available models, and provides basic information about each one such as the owner and
// availability.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - options - APIClientListModelsOptions contains the optional parameters for the APIClient.ListModels method.
func (client *APIClient) ListModels(ctx context.Context, options *APIClientListModelsOptions) (APIClientListModelsResponse, error) {
	var err error
	req, err := client.listModelsCreateRequest(ctx, options)
	if err != nil {
		return APIClientListModelsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientListModelsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientListModelsResponse{}, err
	}
	resp, err := client.listModelsHandleResponse(httpResp)
	return resp, err
}

// listModelsCreateRequest creates the ListModels request.
func (client *APIClient) listModelsCreateRequest(ctx context.Context, options *APIClientListModelsOptions) (*policy.Request, error) {
	urlPath := "/models"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listModelsHandleResponse handles the ListModels response.
func (client *APIClient) listModelsHandleResponse(resp *http.Response) (APIClientListModelsResponse, error) {
	result := APIClientListModelsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.ListModelsResponse); err != nil {
		return APIClientListModelsResponse{}, err
	}
	return result, nil
}

// RetrieveFile - Returns information about a specific file.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - fileID - The ID of the file to use for this request
//   - options - APIClientRetrieveFileOptions contains the optional parameters for the APIClient.RetrieveFile method.
func (client *APIClient) RetrieveFile(ctx context.Context, fileID string, options *APIClientRetrieveFileOptions) (APIClientRetrieveFileResponse, error) {
	var err error
	req, err := client.retrieveFileCreateRequest(ctx, fileID, options)
	if err != nil {
		return APIClientRetrieveFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientRetrieveFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientRetrieveFileResponse{}, err
	}
	resp, err := client.retrieveFileHandleResponse(httpResp)
	return resp, err
}

// retrieveFileCreateRequest creates the RetrieveFile request.
func (client *APIClient) retrieveFileCreateRequest(ctx context.Context, fileID string, options *APIClientRetrieveFileOptions) (*policy.Request, error) {
	urlPath := "/files/{file_id}"
	if fileID == "" {
		return nil, errors.New("parameter fileID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{file_id}", url.PathEscape(fileID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// retrieveFileHandleResponse handles the RetrieveFile response.
func (client *APIClient) retrieveFileHandleResponse(resp *http.Response) (APIClientRetrieveFileResponse, error) {
	result := APIClientRetrieveFileResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.File); err != nil {
		return APIClientRetrieveFileResponse{}, err
	}
	return result, nil
}

// RetrieveFineTune - Gets info about the fine-tune job.
// Learn more about Fine-tuning [/docs/guides/fine-tuning]
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - fineTuneID - The ID of the fine-tune job
//   - options - APIClientRetrieveFineTuneOptions contains the optional parameters for the APIClient.RetrieveFineTune method.
func (client *APIClient) RetrieveFineTune(ctx context.Context, fineTuneID string, options *APIClientRetrieveFineTuneOptions) (APIClientRetrieveFineTuneResponse, error) {
	var err error
	req, err := client.retrieveFineTuneCreateRequest(ctx, fineTuneID, options)
	if err != nil {
		return APIClientRetrieveFineTuneResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientRetrieveFineTuneResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientRetrieveFineTuneResponse{}, err
	}
	resp, err := client.retrieveFineTuneHandleResponse(httpResp)
	return resp, err
}

// retrieveFineTuneCreateRequest creates the RetrieveFineTune request.
func (client *APIClient) retrieveFineTuneCreateRequest(ctx context.Context, fineTuneID string, options *APIClientRetrieveFineTuneOptions) (*policy.Request, error) {
	urlPath := "/fine-tunes/{fine_tune_id}"
	if fineTuneID == "" {
		return nil, errors.New("parameter fineTuneID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{fine_tune_id}", url.PathEscape(fineTuneID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// retrieveFineTuneHandleResponse handles the RetrieveFineTune response.
func (client *APIClient) retrieveFineTuneHandleResponse(resp *http.Response) (APIClientRetrieveFineTuneResponse, error) {
	result := APIClientRetrieveFineTuneResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FineTune); err != nil {
		return APIClientRetrieveFineTuneResponse{}, err
	}
	return result, nil
}

// RetrieveModel - Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
// If the operation fails it returns an *azcore.ResponseError type.
//
// Generated from API version 2.0.0
//   - model - The ID of the model to use for this request
//   - options - APIClientRetrieveModelOptions contains the optional parameters for the APIClient.RetrieveModel method.
func (client *APIClient) RetrieveModel(ctx context.Context, model string, options *APIClientRetrieveModelOptions) (APIClientRetrieveModelResponse, error) {
	var err error
	req, err := client.retrieveModelCreateRequest(ctx, model, options)
	if err != nil {
		return APIClientRetrieveModelResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return APIClientRetrieveModelResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return APIClientRetrieveModelResponse{}, err
	}
	resp, err := client.retrieveModelHandleResponse(httpResp)
	return resp, err
}

// retrieveModelCreateRequest creates the RetrieveModel request.
func (client *APIClient) retrieveModelCreateRequest(ctx context.Context, model string, options *APIClientRetrieveModelOptions) (*policy.Request, error) {
	urlPath := "/models/{model}"
	if model == "" {
		return nil, errors.New("parameter model cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{model}", url.PathEscape(model))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// retrieveModelHandleResponse handles the RetrieveModel response.
func (client *APIClient) retrieveModelHandleResponse(resp *http.Response) (APIClientRetrieveModelResponse, error) {
	result := APIClientRetrieveModelResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Model); err != nil {
		return APIClientRetrieveModelResponse{}, err
	}
	return result, nil
}
